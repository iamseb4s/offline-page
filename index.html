<!DOCTYPE html>
<html lang="en">
  <!--
   __________________________________________________
  /                                                  \
 |                   I caught you!                    |
 |              You can check the repo ;)             |
 |                                                    |
 |     https://github.com/iamseb4s/offline-page       |
  \__________________________________________________/
                    \     _,      ,_
                     \  ."/   ,_   \'.
                       |  \__(  >__/  |
                       \ iamsebas.dev /
                        '-..__  __..-'
                             /__\
    -->
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title data-translate-key="title">Hi, I am Sebas! ðŸ‘¾ | iamsebas.dev</title>
    <link rel="icon" href="" />

    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&display=swap"
      rel="stylesheet"
    />

    <style>
      /* --- CORE STYLES --- */
      body,
      html {
        height: 100%;
        margin: 0;
        font-family: "Inter", system-ui, -apple-system, sans-serif;
        background-color: #050505;
        overflow: hidden;
        user-select: none;
        color: white;
        overscroll-behavior: none;
      }

      #canvas-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 0;
        outline: none;
        background: radial-gradient(circle at center, #111 0%, #000 100%);
      }

      #warp-flash {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #ffffff;
        z-index: 100;
        pointer-events: none;
        opacity: 0;
      }

      /* --- HUD (Top Right) --- */
      #hud-container {
        position: fixed;
        top: 30px;
        right: 30px;
        z-index: 10;
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        gap: 2px;
        pointer-events: none;
      }

      .hud-value {
        font-size: 2rem;
        font-weight: 800;
        letter-spacing: -1px;
        font-variant-numeric: tabular-nums;
      }

      .hud-unit {
        font-size: 1rem;
        color: #fa4601;
        font-weight: 600;
        margin-left: 5px;
        font-family: "Inter", system-ui, -apple-system, sans-serif;
      }

      .hud-label {
        font-size: 0.75rem;
        color: rgba(255, 255, 255, 0.5);
        text-transform: uppercase;
        letter-spacing: 2px;
        font-weight: 600;
        margin-top: 5px;
      }

      .radar-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        display: inline-block;
        margin-right: 6px;
      }
      .status-active {
        background-color: #fa4601;
        box-shadow: 0 0 8px #fa4601;
        animation: pulseRed 1s infinite;
      }
      .status-idle {
        background-color: #444;
      }

      @keyframes pulseRed {
        0% {
          opacity: 0.5;
          transform: scale(1);
        }
        50% {
          opacity: 1;
          transform: scale(1.2);
        }
        100% {
          opacity: 0.5;
          transform: scale(1);
        }
      }

      /* --- CENTER CONTENT --- */
      .container {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;
        min-height: 85vh;
        position: relative;
        z-index: 5;
        padding: 20px;
        pointer-events: none;
        transition: opacity 0.5s ease; /* Para ocultar suavemente al entrar */
      }

      .container * {
        pointer-events: auto;
      }

      .profile-icon {
        margin-bottom: 30px;
        filter: drop-shadow(0 0 20px rgba(255, 255, 255, 0.15));
        transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
      }
      .profile-icon:hover {
        transform: scale(1.1);
      }

      h1 {
        font-size: 3.5em;
        margin: 0;
        color: #fff;
        font-weight: 800;
        letter-spacing: -1.5px;
        text-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      }

      .subtitle {
        font-size: 1.1em;
        margin: 10px 0 10px 0;
        color: rgba(255, 255, 255, 0.7);
        font-weight: 400;
        letter-spacing: 0.5px;
      }

      .bio-card {
        max-width: 650px;
        font-size: 1.1em;
        line-height: 1.6;
        padding: 10px;
        color: rgba(255, 255, 255, 0.9);
      }

      .instruction-hint {
        position: fixed;
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 20;
        padding: 12px 20px;
        text-align: center;
        color: rgba(255, 255, 255, 0.6);
        font-size: 0.75em;
        font-weight: 500;
        letter-spacing: 0.5px;
        white-space: nowrap;
        pointer-events: none;
      }
      .highlight {
        color: #fa4801c5;
        font-weight: 700;
      }

      .brake-hint {
        display: block;
        font-size: 0.9em;
        opacity: 0.7;
        margin-top: 4px;
        color: #fa4601;
      }

      .social-icons {
        margin-top: 10px;
      }
      .social-icons a {
        margin: 0 15px;
        display: inline-block;
        opacity: 0.7;
        transition: all 0.3s ease;
      }
      .social-icons a:hover {
        opacity: 1;
        transform: scale(1.2);
      }
      .social-icons svg {
        width: 40px;
        height: 40px;
        fill: white;
      }

      /* --- JOYSTICK STYLES --- */
      #joystick-base {
        position: fixed;
        width: 120px;
        height: 120px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 50%;
        display: none;
        pointer-events: none;
        transform: translate(-50%, -50%);
        z-index: 20;
      }

      #joystick-nub {
        position: fixed;
        width: 50px;
        height: 50px;
        background: rgba(255, 255, 255, 0.25);
        border-radius: 50%;
        display: none;
        pointer-events: none;
        transform: translate(-50%, -50%);
        z-index: 21;
      }

      #lang-switcher {
        position: fixed;
        top: 30px;
        left: 30px;
        width: 45px;
        height: 45px;
        background: rgba(255, 255, 255, 0.1);
        color: white;
        border-radius: 50%;
        display: flex;
        justify-content: center;
        align-items: center;
        font-weight: bold;
        cursor: pointer;
        z-index: 30;
        font-size: 0.9em;
        transition: background-color 0.3s;
      }
      #lang-switcher:hover {
        background: rgba(255, 255, 255, 0.3);
        transform: scale(1.05);
      }

      @media (max-width: 600px) {
        h1 {
          font-size: 2.2em;
        }
        .bio-card {
          font-size: 0.95em;
        }
        .instruction-hint {
          white-space: normal;
          width: 90%;
          bottom: 20px;
        }
        #hud-container {
          left: 50%;
          transform: translateX(-50%);
          right: auto;
          align-items: center;
        }
      }
    </style>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
      }
    </script>
  </head>
  <body>
    <div id="joystick-base"></div>
    <div id="joystick-nub"></div>
    <div id="lang-switcher">EN</div>

    <svg style="display: none">
      <symbol
        id="icon-sebas"
        viewBox="0 -0.5 22 24"
        shape-rendering="crispEdges"
      >
        <path
          stroke="#fa4601"
          d="M5 0h1M5 1h1M4 2h1M3 3h2M1 4h1M3 4h1M0 5h3M4 5h1M0 6h2M3 6h2M1 7h4M0 8h1M3 8h2M0 9h1M4 9h1M9 9h1M0 10h7M10 10h1M2 11h1M4 11h1M6 11h3M2 12h1M4 12h2M7 12h1M10 12h1M2 13h5M8 13h1M10 13h1M5 14h4M10 14h1M9 16h1M8 17h2M8 18h1M10 18h1M9 19h2M9 20h1M9 21h1"
        />
        <path
          stroke="#d40001"
          d="M13 0h2M15 1h2M15 2h4M16 3h3M16 4h3M21 4h1M16 5h6M16 6h3M20 6h2M17 7h1M19 7h2M16 8h3M21 8h1M16 9h3M20 9h2M12 10h1M15 10h3M20 10h1M13 11h3M17 11h3M12 12h4M12 13h2M15 13h4M13 14h1M16 14h1M12 15h1M11 16h2M11 17h1M12 18h2M12 20h2M14 22h1"
        />
        <path
          stroke="#fa4601"
          d="M4 1h1M3 5h1M2 6h1M2 9h1M5 9h1M3 11h1M8 12h1M7 13h1M9 14h1"
        />
        <path
          stroke="#d40001"
          d="M14 1h1M17 1h1M20 4h1M19 8h1M16 11h1M18 12h1M14 13h1M13 17h1"
        />
        <path stroke="#fa4601" d="M1 3h1M2 8h1M1 9h1M5 11h1M9 13h1" />
        <path
          stroke="#d40001"
          d="M19 6h1M18 7h1M19 9h1M18 10h1M16 12h1M12 19h1"
        />
        <path
          stroke="#d40001"
          d="M16 7h1M19 10h1M12 14h1M15 14h1M12 17h1M14 21h1"
        />
        <path
          stroke="#fa4601"
          d="M3 9h1M1 11h1M10 11h1M3 12h1M6 12h1M9 12h1M6 15h1"
        />
        <path stroke="#fb2000" d="M11 10h1M9 15h1M11 19h1M11 22h1M10 23h1" />
        <path stroke="#fb2000" d="M11 11h1M11 14h1" />
        <path
          stroke="#fb2000"
          d="M11 12h1M11 13h1M10 15h1M10 16h1M10 17h1M11 18h1M11 20h1M11 21h1"
        />
        <path stroke="#fb2000" d="M11 15h1" />
      </symbol>
    </svg>

    <div id="canvas-container"></div>
    <div id="warp-flash"></div>

    <div id="hud-container">
      <div>
        <span id="speed-count" class="hud-value">60,000</span>
        <span class="hud-unit"><strong>KM/S</strong></span>
      </div>
      <div class="hud-label">
        <span id="radar-dot" class="radar-dot status-idle"></span>
        <span data-translate-key="hud_scanner">WORMHOLE SCANNER</span>
      </div>
    </div>

    <div class="container" id="main-ui">
      <svg class="profile-icon" width="130" height="130">
        <use href="#icon-sebas"></use>
      </svg>
      <h1 data-translate-key="h1">Sebas Nolasco</h1>
      <p class="subtitle" data-translate-key="subtitle">
        Data Scientist &middot; Developer &middot; Part-time Astronaut
      </p>

      <div class="bio-card">
        <p data-translate-key="bio">
          <strong>System resources diverted.</strong> <br />
          99% of my computing power is currently training neural networks, so
          the main site is in hibernation mode. While I work on the data, feel
          free to contact me or take the helm of this ship.
        </p>
      </div>

      <div class="social-icons">
        <a href="https://github.com/iamseb4s" aria-label="GitHub">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32">
            <path
              d="M16,2.345c7.735,0,14,6.265,14,14-.002,6.015-3.839,11.359-9.537,13.282-.7,.14-.963-.298-.963-.665,0-.473,.018-1.978,.018-3.85,0-1.312-.437-2.152-.945-2.59,3.115-.35,6.388-1.54,6.388-6.912,0-1.54-.543-2.783-1.435-3.762,.14-.35,.63-1.785-.14-3.71,0,0-1.173-.385-3.85,1.435-1.12-.315-2.31-.472-3.5-.472s-2.38,.157-3.5,.472c-2.677-1.802-3.85-1.435-3.85-1.435-.77,1.925-.28,3.36-.14,3.71-.892,.98-1.435,2.24-1.435,3.762,0,5.355,3.255,6.563,6.37,6.913-.403,.35-.77,.963-.893,1.872-.805,.368-2.818,.963-4.077-1.155-.263-.42-1.05-1.452-2.152-1.435-1.173,.018-.472,.665,.017,.927,.595,.332,1.277,1.575,1.435,1.978,.28,.787,1.19,2.293,4.707,1.645,0,1.173,.018,2.275,.018,2.607,0,.368-.263,.787-.963,.665-5.719-1.904-9.576-7.255-9.573-13.283,0-7.735,6.265-14,14-14Z"
            ></path>
          </svg>
        </a>
        <a
          href="https://www.linkedin.com/in/sebasnolascop/"
          aria-label="LinkedIn"
        >
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32">
            <path
              d="M26.111,3H5.889c-1.595,0-2.889,1.293-2.889,2.889V26.111c0,1.595,1.293,2.889,2.889,2.889H26.111c1.595,0,2.889-1.293,2.889-2.889V5.889c0-1.595-1.293-2.889-2.889-2.889ZM10.861,25.389h-3.877V12.87h3.877v12.519Zm-1.957-14.158c-1.267,0-2.293-1.034-2.293-2.31s1.026-2.31,2.293-2.31,2.292,1.034,2.292,2.31-1.026,2.31-2.292,2.31Zm16.485,14.158h-3.858v-6.571c0-1.802-.685-2.809-2.111-2.809-1.551,0-2.362,1.048-2.362,2.809v6.571h-3.718V12.87h3.718v1.686s1.118-2.069,3.775-2.069,4.556,1.621,4.556,4.975v7.926Z"
              fill-rule="evenodd"
            ></path>
          </svg>
        </a>
        <a href="mailto:sebas@iamsebas.dev" aria-label="Mail">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            height="30px"
            width="30px"
            viewBox="0 -960 960 960"
          >
            <path
              d="M160-160q-33 0-56.5-23.5T80-240v-480q0-33 23.5-56.5T160-800h640q33 0 56.5 23.5T880-720v480q0 33-23.5 56.5T800-160H160Zm320-280L160-640v400h640v-400L480-440Zm0-80 320-200H160l320 200ZM160-640v-80 480-400Z"
            />
          </svg>
        </a>
      </div>
    </div>

    <div class="instruction-hint">
      <span class="highlight" data-translate-key="mission">MISSION:</span>
      <span data-translate-key="mission_text"
        >Locate the
        <span style="color: #fa4801c5">Einstein-Rosen Bridge (Wormhole)</span>
        to warp speed out of here.</span
      >
      <span class="brake-hint" data-translate-key="brake_hint"
        >Click & Hold to Brake</span
      >
    </div>

    <script>
      const symbol = document.getElementById("icon-sebas");
      const fullSvg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${symbol.getAttribute(
        "viewBox"
      )}" shape-rendering="crispEdges">${symbol.innerHTML}</svg>`;
      document
        .querySelector('link[rel="icon"]')
        .setAttribute(
          "href",
          `data:image/svg+xml,${encodeURIComponent(fullSvg)}`
        );
    </script>

    <script type="module">
      import * as THREE from "three";

      // --- CONFIGURATION ---
      const CONFIG = {
        baseFlightSpeed: 750,
        brakeFactor: 0.3,
        starCount: 1500,
        depth: 4000,
        fov: 80,
        turnSpeed: 1.5,
        tunnelDepth: 4000, // Increased length for longer travel
        tunnelBendForce: 600, // Higher curvature force
      };

      const speedEl = document.getElementById("speed-count");
      const radarDot = document.getElementById("radar-dot");
      const warpFlash = document.getElementById("warp-flash");
      const joystickBase = document.getElementById("joystick-base");
      const joystickNub = document.getElementById("joystick-nub");
      const langSwitcher = document.getElementById("lang-switcher");
      const mainUI = document.getElementById("main-ui");

      // --- THREE.JS SETUP ---
      const scene = new THREE.Scene();
      scene.fog = new THREE.Fog(0x000000, CONFIG.depth - 1000, CONFIG.depth);

      const camera = new THREE.PerspectiveCamera(
        CONFIG.fov,
        window.innerWidth / window.innerHeight,
        1, // Small near plane to avoid clipping the tunnel
        CONFIG.depth + 10000
      );
      camera.position.set(0, 0, 0);

      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document
        .getElementById("canvas-container")
        .appendChild(renderer.domElement);

      // --- STAR LINES ---
      const starGeo = new THREE.BufferGeometry();
      const positions = new Float32Array(CONFIG.starCount * 6);
      const velocities = new Float32Array(CONFIG.starCount);
      const spread = 4000;
      const halfSpread = spread / 2;

      for (let i = 0; i < CONFIG.starCount; i++) {
        const i6 = i * 6;
        const x = (Math.random() - 0.5) * spread;
        const y = (Math.random() - 0.5) * spread;
        const z = (Math.random() - 0.5) * spread;
        positions[i6] = x;
        positions[i6 + 1] = y;
        positions[i6 + 2] = z;
        positions[i6 + 3] = x;
        positions[i6 + 4] = y;
        positions[i6 + 5] = z;
        velocities[i] = 1 + Math.random();
      }

      starGeo.setAttribute("position", new THREE.BufferAttribute(positions, 3));
      const starMat = new THREE.LineBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.6,
      });
      const stars = new THREE.LineSegments(starGeo, starMat);
      scene.add(stars);

      // --- BLACK HOLE GROUP ---
      const blackHoleGroup = new THREE.Group();
      scene.add(blackHoleGroup);

      const TUNNEL_CONFIG = {
        topRadius: 150,
        bottomRadius: 60,
        depth: CONFIG.tunnelDepth,
        segmentsVert: 60, // Higher resolution for smooth travel
        segmentsRad: 30,
        bendStart: 0.1,
        fadeStart: 0.01,
        wallOpacity: 0.5,
        wireframeOpacity: 0.4, // More visible
      };

      // --- MATH HELPER FOR CURVE ---
      // Shared function between geometry and camera
      // Returns X offset for a given depth (0 to 1)
      function getCurveOffset(depthRatio) {
        if (depthRatio <= TUNNEL_CONFIG.bendStart) return 0;
        const effectiveBendRatio =
          (depthRatio - TUNNEL_CONFIG.bendStart) /
          (1 - TUNNEL_CONFIG.bendStart);
        return CONFIG.tunnelBendForce * Math.pow(effectiveBendRatio, 2);
      }

      const wellPoints = [];
      for (let i = 0; i <= TUNNEL_CONFIG.segmentsVert; i++) {
        const t = i / TUNNEL_CONFIG.segmentsVert;
        const radius =
          TUNNEL_CONFIG.bottomRadius +
          (TUNNEL_CONFIG.topRadius - TUNNEL_CONFIG.bottomRadius) *
            Math.pow(1 - t, 5);
        // Generate straight tube in Y, curve applied in vertex loop
        const y = -TUNNEL_CONFIG.depth * t;
        wellPoints.push(new THREE.Vector2(radius, y));
      }

      const wellGeo = new THREE.LatheGeometry(
        wellPoints,
        TUNNEL_CONFIG.segmentsRad
      );
      const pos = wellGeo.attributes.position;
      const count = pos.count;
      const colors = new Float32Array(count * 3);
      const alphas = new Float32Array(count);

      const cRed = new THREE.Color(0xffaa00);
      const cOrange = new THREE.Color(0xffaa00);
      const cAmber = new THREE.Color(0xffaa33);
      const tempColor = new THREE.Color();

      for (let i = 0; i < count; i++) {
        const y = pos.getY(i);
        const x = pos.getX(i);
        const depthRatio = Math.abs(y / TUNNEL_CONFIG.depth);

        // Apply curve to mesh
        const bendAmount = getCurveOffset(depthRatio);
        pos.setX(i, x + bendAmount);

        // COLORS
        if (depthRatio < 0.15) {
          tempColor.copy(cRed).lerp(cOrange, depthRatio / 0.15);
        } else if (depthRatio < 0.3) {
          tempColor.copy(cOrange).lerp(cAmber, (depthRatio - 0.15) / 0.15);
        } else {
          tempColor.copy(cAmber);
        }
        colors[i * 3] = tempColor.r;
        colors[i * 3 + 1] = tempColor.g;
        colors[i * 3 + 2] = tempColor.b;

        // ALPHA
        let alpha = 1.0;
        if (depthRatio > TUNNEL_CONFIG.fadeStart) {
          const fadeProgress =
            (depthRatio - TUNNEL_CONFIG.fadeStart) /
            (1.0 - TUNNEL_CONFIG.fadeStart);
          alpha = 1.0 - fadeProgress;
          alpha = Math.max(0, alpha);
          alpha = Math.pow(alpha, 2);
        }
        alphas[i] = alpha;
      }

      wellGeo.setAttribute("color", new THREE.BufferAttribute(colors, 3));
      wellGeo.setAttribute("alpha", new THREE.BufferAttribute(alphas, 1));

      // WIREFRAME SETUP (Visible wireframe)
      const lineGeo = new THREE.BufferGeometry();
      lineGeo.setAttribute("position", wellGeo.attributes.position);
      lineGeo.setAttribute("color", wellGeo.attributes.color);
      lineGeo.setAttribute("alpha", wellGeo.attributes.alpha);
      const lineIndices = [];
      const pointsPerCol = TUNNEL_CONFIG.segmentsVert + 1;

      for (let i = 0; i <= TUNNEL_CONFIG.segmentsRad; i++) {
        for (let j = 0; j < TUNNEL_CONFIG.segmentsVert; j++) {
          const current = i * pointsPerCol + j;
          lineIndices.push(current, current + 1);
        }
      }
      for (let i = 0; i < TUNNEL_CONFIG.segmentsRad; i++) {
        for (let j = 0; j <= TUNNEL_CONFIG.segmentsVert; j++) {
          const current = i * pointsPerCol + j;
          const right = (i + 1) * pointsPerCol + j;
          lineIndices.push(current, right);
        }
      }
      lineGeo.setIndex(lineIndices);

      const wireMat = new THREE.LineBasicMaterial({
        vertexColors: true,
        transparent: true,
        opacity: TUNNEL_CONFIG.wireframeOpacity,
        blending: THREE.AdditiveBlending,
        depthTest: true,
      });

      // Inject Shader for Alpha on Wireframe
      wireMat.onBeforeCompile = (shader) => {
        shader.vertexShader = `
          attribute float alpha;
          varying float vAlpha;
          ${shader.vertexShader}
        `.replace(
          `#include <color_vertex>`,
          `#include <color_vertex>\n vAlpha = alpha;`
        );
        shader.fragmentShader = `
          varying float vAlpha;
          ${shader.fragmentShader}
        `.replace(
          `#include <color_fragment>`,
          `#include <color_fragment>\n diffuseColor.a *= vAlpha;`
        );
      };

      const wireMesh = new THREE.LineSegments(lineGeo, wireMat);
      wireMesh.rotation.x = Math.PI / 2;
      wireMesh.scale.set(0.98, 0.98, 0.98);
      wireMesh.renderOrder = 2;
      blackHoleGroup.add(wireMesh);

      // INNER HULL (Black background of the tube)
      const innerHullMat = new THREE.MeshBasicMaterial({
        color: 0x000000,
        side: THREE.FrontSide, // Visible from inside
        transparent: false,
      });
      const innerHull = new THREE.Mesh(wellGeo, innerHullMat);
      innerHull.rotation.x = Math.PI / 2;
      innerHull.scale.set(0.99, 0.99, 0.99);
      innerHull.renderOrder = -1;
      blackHoleGroup.add(innerHull);

      // 2. OUTER HULL (Invisible occluder from outside)
      const outerHullMat = new THREE.MeshBasicMaterial({
        colorWrite: false,
        depthWrite: true,
        side: THREE.BackSide,
      });
      const outerHull = new THREE.Mesh(wellGeo, outerHullMat);
      outerHull.rotation.x = Math.PI / 2;
      outerHull.scale.set(1.005, 1.005, 1.005);
      outerHull.renderOrder = -2;
      blackHoleGroup.add(outerHull);

      // GLOW
      function createGlowTexture() {
        const canvas = document.createElement("canvas");
        canvas.width = 512;
        canvas.height = 512;
        const ctx = canvas.getContext("2d");
        const c = 256;
        const grd = ctx.createRadialGradient(c, c, 180, c, c, 256);
        grd.addColorStop(0.0, "rgba(0, 0, 0, 0)");
        grd.addColorStop(0.4, "rgba(212, 0, 1, 0.05)");
        grd.addColorStop(0.6, "rgba(251, 32, 0, 0.4)");
        grd.addColorStop(0.8, "rgba(250, 70, 1, 1.0)");
        grd.addColorStop(1.0, "rgba(0, 0, 0, 0)");
        ctx.fillStyle = grd;
        ctx.fillRect(0, 0, 512, 512);
        return new THREE.CanvasTexture(canvas);
      }
      const glowSize = TUNNEL_CONFIG.topRadius * 2.3;
      const glowMesh = new THREE.Mesh(
        new THREE.PlaneGeometry(glowSize, glowSize),
        new THREE.MeshBasicMaterial({
          map: createGlowTexture(),
          transparent: true,
          opacity: 1.2,
          side: THREE.DoubleSide,
          depthWrite: false,
          blending: THREE.AdditiveBlending,
        })
      );
      glowMesh.position.z = 20; // Slightly in front to avoid clipping
      blackHoleGroup.add(glowMesh);

      blackHoleGroup.position.set(0, 0, -5000);
      blackHoleGroup.visible = false;

      // --- LOGIC VARS ---
      let savedScore = localStorage.getItem("interstellar_score");
      let score = savedScore ? parseInt(savedScore) : 0;
      let currentSpeed = CONFIG.baseFlightSpeed;
      let isBraking = false;
      let isWarping = false; // General event state
      let isInTunnel = false; // Specific state "inside tunnel"
      let tunnelProgress = 0; // 0.0 to 1.0

      let mouse = { x: 0, y: 0 };
      let useGyro = false;

      let lastTime = performance.now();

      // --- INPUT HANDLING ---
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      document.addEventListener("mousemove", (e) => {
        if (!useGyro && !isTouching && !isInTunnel) {
          mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
          mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        }
      });

      window.addEventListener("mousedown", () => {
        isBraking = true;
      });
      window.addEventListener("mouseup", () => {
        isBraking = false;
      });

      let touchStartX = 0,
        touchStartY = 0;
      let isTouching = false;

      window.addEventListener(
        "touchstart",
        (e) => {
          isBraking = true;
          if (!useGyro && typeof DeviceOrientationEvent !== "undefined") {
            initGyro();
          }
          const t = e.touches[0];
          touchStartX = t.clientX;
          touchStartY = t.clientY;
          isTouching = true;
          if (!isInTunnel) {
            joystickBase.style.display = "block";
            joystickNub.style.display = "block";
            joystickBase.style.left = touchStartX + "px";
            joystickBase.style.top = touchStartY + "px";
            joystickNub.style.left = touchStartX + "px";
            joystickNub.style.top = touchStartY + "px";
          }
        },
        { passive: false }
      );

      window.addEventListener(
        "touchmove",
        (e) => {
          if (useGyro || !isTouching || isInTunnel) return;
          e.preventDefault();
          const t = e.touches[0];
          const diffX = t.clientX - touchStartX;
          const diffY = t.clientY - touchStartY;
          const maxDist = 60;
          const angle = Math.atan2(diffY, diffX);
          const dist = Math.min(
            Math.sqrt(diffX * diffX + diffY * diffY),
            maxDist
          );
          const nubX = touchStartX + Math.cos(angle) * dist;
          const nubY = touchStartY + Math.sin(angle) * dist;
          joystickNub.style.left = nubX + "px";
          joystickNub.style.top = nubY + "px";
          mouse.x = diffX / 100;
          mouse.y = -(diffY / 100);
        },
        { passive: false }
      );

      window.addEventListener("touchend", () => {
        isBraking = false;
        isTouching = false;
        joystickBase.style.display = "none";
        joystickNub.style.display = "none";
        if (!useGyro) {
          mouse.x = 0;
          mouse.y = 0;
        }
      });

      function handleOrientation(event) {
        if (!event.alpha && !event.beta) return;
        let yTilt = event.beta - 45;
        let xTilt = event.gamma;
        const tiltClamp = 40;
        xTilt = Math.max(-tiltClamp, Math.min(tiltClamp, xTilt));
        yTilt = Math.max(-tiltClamp, Math.min(tiltClamp, yTilt));
        if (!isInTunnel) {
          mouse.x = xTilt / tiltClamp;
          mouse.y = -yTilt / tiltClamp;
        }
      }

      function initGyro() {
        if (typeof DeviceOrientationEvent.requestPermission === "function") {
          DeviceOrientationEvent.requestPermission()
            .then((state) => {
              if (state === "granted") {
                useGyro = true;
                window.addEventListener("deviceorientation", handleOrientation);
              }
            })
            .catch((e) => console.log(e));
        } else if (window.DeviceOrientationEvent) {
          const tempHandler = (e) => {
            if (e.alpha || e.beta) {
              useGyro = true;
              window.removeEventListener("deviceorientation", tempHandler);
              window.addEventListener("deviceorientation", handleOrientation);
            }
          };
          window.addEventListener("deviceorientation", tempHandler);
        }
      }

      // --- GAME FUNCTIONS ---
      function spawnBlackHole() {
        if (isWarping) return;
        blackHoleGroup.visible = true;
        blackHoleGroup.scale.set(1, 1, 1);
        const dist = CONFIG.depth * 1.5;
        const difficulty = Math.min(score, 30) / 30;
        const maxSpread = THREE.MathUtils.degToRad(10 + difficulty * 130);
        const angleX = (Math.random() - 0.5) * maxSpread;
        const angleY = (Math.random() - 0.5) * maxSpread;
        const spawnPos = new THREE.Vector3(0, 0, -dist);
        spawnPos.applyEuler(new THREE.Euler(angleX, angleY, 0));
        spawnPos.applyQuaternion(camera.quaternion);
        blackHoleGroup.position.copy(spawnPos);
        updateRadar(true);
      }

      function updateRadar(active) {
        radarDot.className = active
          ? "radar-dot status-active"
          : "radar-dot status-idle";
      }

      // Start entry sequence
      function enterWormhole() {
        if (isInTunnel || isWarping) return;
        isWarping = true;
        isInTunnel = true;
        tunnelProgress = 0;

        // Hide UI
        mainUI.style.opacity = 0;
        joystickBase.style.display = "none";
        joystickNub.style.display = "none";

        // Freeze hole at origin to travel INSIDE it
        // Reset camera rotation to align with tunnel
        blackHoleGroup.position.set(0, 0, 0);
        blackHoleGroup.rotation.set(0, 0, 0);
        camera.position.set(0, 0, 0);
        camera.rotation.set(0, 0, 0);

        // Scale adjustment for massive feel on entry
        blackHoleGroup.scale.set(1, 1, 1);
      }

      // End sequence (Exit and reset)
      function finishWarp() {
        score++;
        localStorage.setItem("interstellar_score", score);
        blackHoleGroup.visible = false;
        isInTunnel = false;
        isWarping = false;
        tunnelProgress = 0;
        warpFlash.style.opacity = 0;
        updateRadar(false);

        // Restore UI
        mainUI.style.opacity = 1;
        camera.position.set(0, 0, 0);
        camera.rotation.set(0, 0, 0); // Reset rotation

        setTimeout(spawnBlackHole, Math.random() * 5000 + 2000);
      }

      setTimeout(spawnBlackHole, 3000);

      // --- ANIMATION LOOP ---
      const clock = new THREE.Clock();
      const forwardVec = new THREE.Vector3(0, 0, -1);
      const velocityVec = new THREE.Vector3();
      const dummyVec = new THREE.Vector3();

      const MAX_SPEED_CAP = 299492; // 99.9% EXACT CAP

      let currentDisplayVal = 60000;
      let lastTextUpdate = 0;

      function animate() {
        const time = performance.now();
        const delta = clock.getDelta();

        // UI Speed calculation
        const progressionCurve = 1 - Math.exp(-score * 0.03);
        // Start from 60k, go up to MAX_SPEED_CAP based on score
        let targetDisplayVal =
          60000 + (MAX_SPEED_CAP - 60000) * progressionCurve;

        if (isBraking) {
          targetDisplayVal *= CONFIG.brakeFactor;
        } else if (isInTunnel) {
          // Constant max speed in tunnel
          targetDisplayVal = MAX_SPEED_CAP;
        }

        // Absolute Hard Limiter
        if (targetDisplayVal > MAX_SPEED_CAP) targetDisplayVal = MAX_SPEED_CAP;

        currentDisplayVal += (targetDisplayVal - currentDisplayVal) * 0.1;

        // Redundant safety check
        if (currentDisplayVal > MAX_SPEED_CAP)
          currentDisplayVal = MAX_SPEED_CAP;

        const ratio = currentDisplayVal / 60000;
        currentSpeed = 600 * Math.pow(ratio, 1.43);

        // --- Tunnel Logic ---
        if (isInTunnel) {
          tunnelProgress += delta * 0.4;

          if (tunnelProgress >= 1.0) {
            finishWarp();
          } else {
            const currentZ = -TUNNEL_CONFIG.depth * tunnelProgress;
            const bendX = getCurveOffset(tunnelProgress);

            camera.position.set(bendX, 0, currentZ);

            const lookAheadStep = 0.05;
            const lookAtZ =
              -TUNNEL_CONFIG.depth * (tunnelProgress + lookAheadStep);
            const lookAtX = getCurveOffset(
              Math.min(1, tunnelProgress + lookAheadStep)
            );
            camera.lookAt(lookAtX, 0, lookAtZ);

            camera.rotation.z = Math.sin(time * 0.005) * 0.2;

            if (tunnelProgress > 0.35) {
              const flashOpacity = (tunnelProgress - 0.35) / 0.4;
              warpFlash.style.opacity = Math.min(1, Math.max(0, flashOpacity));
            } else {
              warpFlash.style.opacity = 0;
            }
          }
        }
        // --- Normal Flight Logic ---
        else {
          camera.rotateX(mouse.y * CONFIG.turnSpeed * delta);
          camera.rotateY(-mouse.x * CONFIG.turnSpeed * delta);

          velocityVec
            .copy(forwardVec)
            .applyQuaternion(camera.quaternion)
            .multiplyScalar(currentSpeed * delta);

          if (blackHoleGroup.visible) {
            blackHoleGroup.position.sub(velocityVec);
            blackHoleGroup.lookAt(camera.position);

            const distToHole = blackHoleGroup.position.length();

            // Dynamic Hitbox
            const hitbox = Math.max(200, currentSpeed * delta * 1.5);

            if (distToHole < hitbox) {
              enterWormhole(); // Direct Entry
            }

            if (distToHole > CONFIG.depth * 2.5) {
              blackHoleGroup.visible = false;
              updateRadar(false);
              setTimeout(spawnBlackHole, 1000);
            }
          }

          // Stars
          const stretchFactor = isBraking ? 0.04 : 0.06;

          dummyVec
            .copy(velocityVec)
            .normalize()
            .multiplyScalar(currentSpeed * stretchFactor);

          for (let i = 0; i < CONFIG.starCount; i++) {
            const i6 = i * 6;
            posArr[i6] -= velocityVec.x;
            posArr[i6 + 1] -= velocityVec.y;
            posArr[i6 + 2] -= velocityVec.z;
            if (posArr[i6] > halfSpread) posArr[i6] -= spread;
            else if (posArr[i6] < -halfSpread) posArr[i6] += spread;
            if (posArr[i6 + 1] > halfSpread) posArr[i6 + 1] -= spread;
            else if (posArr[i6 + 1] < -halfSpread) posArr[i6 + 1] += spread;
            if (posArr[i6 + 2] > halfSpread) posArr[i6 + 2] -= spread;
            else if (posArr[i6 + 2] < -halfSpread) posArr[i6 + 2] += spread;
            posArr[i6 + 3] = posArr[i6] + dummyVec.x;
            posArr[i6 + 4] = posArr[i6 + 1] + dummyVec.y;
            posArr[i6 + 5] = posArr[i6 + 2] + dummyVec.z;
          }
          posAttr.needsUpdate = true;
        }

        // UI Updates
        if (time - lastTextUpdate > 20) {
          // Display capped value
          let uiSpeed = Math.min(currentDisplayVal, MAX_SPEED_CAP);
          speedEl.innerText = Math.floor(uiSpeed).toLocaleString();

          lastTextUpdate = time;
        }
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }

      // Star Array Ref
      const posAttr = starGeo.attributes.position;
      const posArr = posAttr.array;

      animate();

      // --- Translations ---
      const translations = {
        en: {
          title: "Hi, I am Sebas! ðŸ‘¾ | iamsebas.dev",
          h1: "Sebas Nolasco",
          subtitle:
            "Data Scientist &middot; Developer &middot; Part-time Astronaut",
          bio: `<strong>System resources diverted.</strong> <br /> 99% of my computing power is currently training neural networks, so the main site is in hibernation mode. While I work on the data, feel free to contact me or take the helm of this ship.`,
          mission: "MISSION:",
          mission_text: `Navigate through an <span style='color: #fa4801c5'>Einstein-Rosen Bridge (Wormhole)</span> to find a shortcut in time to the main page.`,
          brake_hint: "Use your device to steer, press and hold to brake.",
          hud_scanner: "WORMHOLE SCANNER",
        },
        es: {
          title: "Â¡Hola, soy Sebas! ðŸ‘¾ | iamsebas.dev",
          h1: "Sebas Nolasco",
          subtitle:
            "CientÃ­fico de Datos &middot; Desarrollador &middot; Astronauta a medio tiempo",
          bio: `<strong>Recursos del sistema desviados.</strong> <br /> El 99% de mi potencia de cÃ¡lculo estÃ¡ entrenando redes neuronales, por lo que el sitio principal estÃ¡ en modo de hibernaciÃ³n. Mientras trabajo en los datos, siÃ©ntete libre de contactarme o tomar el timÃ³n de esta nave.`,
          mission: "MISIÃ“N:",
          mission_text: `Navega a travÃ©s de un <span style='color: #fa4801c5'>Puente Einstein-Rosen (Agujero de Gusano)</span> para encontrar un atajo en el tiempo a la pÃ¡gina principal.`,
          brake_hint:
            "Usa tu dispositivo para pilotar, mantÃ©n pulsado para frenar.",
          hud_scanner: "ESCÃNER DE AGUJEROS",
        },
      };

      let currentLang = "en";
      function setLanguage(lang) {
        if (!translations[lang]) return;
        currentLang = lang;
        langSwitcher.innerText = lang.toUpperCase();
        document.querySelectorAll("[data-translate-key]").forEach((el) => {
          const key = el.getAttribute("data-translate-key");
          if (translations[lang][key]) {
            if (key === "title") document.title = translations[lang][key];
            else el.innerHTML = translations[lang][key];
          }
        });
      }

      const userLang = (navigator.language || "en").slice(0, 2);
      setLanguage(userLang === "es" ? "es" : "en");
      langSwitcher.addEventListener("click", () => {
        const newLang = currentLang === "en" ? "es" : "en";
        setLanguage(newLang);
      });
    </script>
  </body>
</html>
